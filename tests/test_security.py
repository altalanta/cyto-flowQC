from __future__ import annotations

import json
import os
import tempfile
from pathlib import Path
from unittest.mock import patch

import pandas as pd
import pytest
from faker import Faker

from cytoflow_qc.security import DataAnonymizer, DataEncryptor, RBACManager, SecurityError

# Fixtures for setup
@pytest.fixture
def fake_data_df() -> pd.DataFrame:
    faker = Faker()
    return pd.DataFrame({
        "patient_id": [faker.uuid4() for _ in range(3)],
        "patient_name": [faker.name() for _ in range(3)],
        "email": [faker.email() for _ in range(3)],
        "age": [faker.random_int(min=18, max=80) for _ in range(3)],
        "FSC-A": [1000, 1500, 1200],
        "SSC-A": [500, 700, 600],
    })

@pytest.fixture
def encryption_key_file(tmp_path: Path) -> Path:
    key_file = tmp_path / "encryption.key"
    # Key will be generated by DataEncryptor if not present
    return key_file

@pytest.fixture
def rbac_policy_file(tmp_path: Path) -> Path:
    policy_data = {
        "roles": {
            "custom_admin": {"permissions": ["read", "write", "delete", "manage"]},
            "custom_viewer": {"permissions": ["read"]},
        },
        "resources": {
            "clinical_data": {"protected_by": ["custom_admin"]},
            "public_reports": {"protected_by": ["custom_admin", "custom_viewer"]},
        }
    }
    policy_file = tmp_path / "custom_policy.json"
    with open(policy_file, 'w') as f:
        json.dump(policy_data, f)
    return policy_file


# Test DataAnonymizer
class TestDataAnonymizer:
    def test_anonymize_dataframe_no_identifier(self, fake_data_df: pd.DataFrame):
        anonymizer = DataAnonymizer(seed=123) # Seed for reproducibility
        columns_to_anonymize = ["patient_name", "email"]
        df_anon = anonymizer.anonymize_dataframe(fake_data_df, columns_to_anonymize)

        assert not df_anon.equals(fake_data_df) # Ensure changes were made
        for col in columns_to_anonymize:
            for original, anonymized in zip(fake_data_df[col], df_anon[col]):
                assert original != anonymized # Values should be different

        assert df_anon["patient_id"].equals(fake_data_df["patient_id"]) # Non-anonymized columns unchanged

    def test_anonymize_dataframe_with_identifier(self, fake_data_df: pd.DataFrame):
        anonymizer = DataAnonymizer(seed=123)
        columns_to_anonymize = ["patient_name", "email"]
        df_anon = anonymizer.anonymize_dataframe(fake_data_df, columns_to_anonymize, "patient_id")

        # Check if identical original identifiers map to identical anonymized values
        original_patient_name = fake_data_df["patient_name"].iloc[0]
        anonymized_patient_name = df_anon["patient_name"].iloc[0]
        assert anonymizer.get_anonymization_mapping()["patient_name"][original_patient_name] == anonymized_patient_name

    def test_anonymize_missing_column(self, fake_data_df: pd.DataFrame):
        anonymizer = DataAnonymizer(seed=123)
        columns_to_anonymize = ["non_existent_col"]
        df_anon = anonymizer.anonymize_dataframe(fake_data_df, columns_to_anonymize)
        assert df_anon.equals(fake_data_df) # No changes if column is missing


# Test DataEncryptor
class TestDataEncryptor:
    def test_encrypt_decrypt_data(self):
        encryptor = DataEncryptor() # Key generated automatically
        original_data = b"My secret data string"
        encrypted_data = encryptor.encrypt_data(original_data)
        decrypted_data = encryptor.decrypt_data(encrypted_data)

        assert original_data != encrypted_data
        assert original_data == decrypted_data

    def test_encrypt_decrypt_file(self, tmp_path: Path, encryption_key_file: Path):
        original_file = tmp_path / "original.txt"
        encrypted_file = tmp_path / "encrypted.txt"
        decrypted_file = tmp_path / "decrypted.txt"

        original_content = b"This is a test file for encryption."
        with open(original_file, 'wb') as f:
            f.write(original_content)

        encryptor = DataEncryptor(key_path=encryption_key_file)
        encryptor.encrypt_file(original_file, encrypted_file)

        assert encrypted_file.exists()
        assert encrypted_file.read_bytes() != original_content

        encryptor.decrypt_file(encrypted_file, decrypted_file)

        assert decrypted_file.exists()
        assert decrypted_file.read_bytes() == original_content

    def test_encrypt_file_not_found(self, tmp_path: Path):
        encryptor = DataEncryptor()
        with pytest.raises(FileNotFoundError):
            encryptor.encrypt_file(tmp_path / "non_existent.txt", tmp_path / "output.txt")

    def test_decrypt_file_not_found(self, tmp_path: Path):
        encryptor = DataEncryptor()
        with pytest.raises(FileNotFoundError):
            encryptor.decrypt_file(tmp_path / "non_existent.txt", tmp_path / "output.txt")

    def test_encryption_key_env_var(self):
        with patch.dict(os.environ, {"CYTOFLOW_QC_ENCRYPTION_KEY": Fernet.generate_key().decode()}):
            encryptor = DataEncryptor()
            assert encryptor.key == os.getenv("CYTOFLOW_QC_ENCRYPTION_KEY").encode()

    def test_security_error_no_key(self):
        # Ensure no key is present in env or path
        with patch.dict(os.environ, {}, clear=True), \
             patch('builtins.print'): # Suppress print for new key generation message
            encryptor = DataEncryptor()
            assert isinstance(encryptor.key, bytes)


# Test RBACManager
class TestRBACManager:
    def test_default_policies(self):
        rbac = RBACManager()
        assert rbac.check_permission(["admin"], "read", "data_raw")
        assert not rbac.check_permission(["viewer"], "write", "configs")

    def test_custom_policies(self, rbac_policy_file: Path):
        rbac = RBACManager(policy_file=rbac_policy_file)
        assert rbac.check_permission(["custom_admin"], "write", "clinical_data")
        assert not rbac.check_permission(["custom_viewer"], "delete", "public_reports")
        assert rbac.check_permission(["custom_viewer"], "read", "public_reports")

    def test_undefined_resource(self):
        rbac = RBACManager()
        assert not rbac.check_permission(["admin"], "read", "non_existent_resource")

    def test_enforce_access_decorator_success(self):
        rbac = RBACManager()
        user_roles = ["admin"]

        @rbac.enforce_access(user_roles, "write", "configs")
        def mock_func():
            return "Access Granted"

        assert mock_func() == "Access Granted"

    def test_enforce_access_decorator_failure(self):
        rbac = RBACManager()
        user_roles = ["viewer"]

        @rbac.enforce_access(user_roles, "write", "configs")
        def mock_func():
            return "Access Granted"

        with pytest.raises(SecurityError, match="Permission denied"):
            mock_func()




